{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Agent Flavored Markdown (AFM)","text":"<p>A simple, markdown-based format for defining AI agents. Write agents in plain text that any platform can understand and deploy.</p> <pre><code># Role\nI'm a friendly math tutor who explains concepts step-by-step.\n\n# Instructions\n- Use simple language\n- Show your work\n- Be encouraging and patient\n</code></pre>"},{"location":"#why-afm","title":"Why AFM?","text":"<ul> <li> <p> Simple</p> <p>Write agents in plain markdown. No complex code or proprietary formats required.</p> </li> <li> <p> Shareable</p> <p>AFM agents work across different platforms and tools. Write once, deploy anywhere.</p> </li> <li> <p> Collaborative</p> <p>Build multi-agent systems where agents work together to solve complex problems.</p> </li> </ul> <p>Want to learn more? Check out Why AFM? to understand the problem AFM solves and how it compares to other approaches.</p>"},{"location":"#get-started","title":"Get Started","text":"Read the Spec Visualizer Learn More"},{"location":"specification/","title":"AFM Specification","text":""},{"location":"specification/#1-introduction","title":"1. Introduction","text":"<p>AFM (Agent Flavored Markdown) provides a structured, markdown-based format for defining the capabilities, behaviors, and knowledge of AI agents. The goal is to create a universal standard that allows agents to be easily defined, shared, and deployed.</p> <p>AFM is designed to be composable. It supports not only the definition of individual agents but also complex, multi-agent systems where agents can expose services for other agents to consume.</p> <p>This document details the AFM file format, its syntax, and the schema for defining an agent.</p>"},{"location":"specification/#11-key-goals-of-afm","title":"1.1. Key Goals of AFM","text":"<p>AFM addresses the current fragmentation in the AI agent ecosystem by providing a unified standard for agent definition and interoperability:</p> <ul> <li>Simple Syntax: Move away from complex, imperative code. AFM allows developers to declare an agent's properties, tools, and configurations in a simple, text-based format.</li> <li>Human-Readability: AFM uses a simple, elegant markdown-based syntax that is intuitive for both developers and non-technical stakeholders to read, write, and understand.</li> <li>Adaptable: By building the framework around a flexible format rather than embedding it deep within a programming language, we can evolve the standard alongside the fast-changing AI landscape.</li> <li>Unified Experience: Provide a clean, declarative model that works seamlessly for both developers writing code and those using visual, low-code interfaces. The same AFM file can power both experiences.</li> <li>Agent Duality: Natively support the dual nature of agents as both callable functions within an application (i.e. Ambiant Agent) and as exposable services (i.e. Chat Agent) for interoperability.</li> <li>Interoperability: AFM provides a standard, unambiguous syntax for agent definition, ensuring that diverse platforms and tools can consistently use the same agent blueprint.</li> </ul>"},{"location":"specification/#2-core-concepts","title":"2. Core Concepts","text":"<p>AFM is built around several core concepts that define how agents are structured and interact:</p> <ul> <li>Agent: The primary entity defined in AFM, representing an AI agent with specific capabilities and behaviors.</li> <li>Role: A specific function or set of responsibilities that an agent can perform, described in natural language within a specific context.</li> <li>Instructions: Natural language directives that guide the agent's behavior and task execution, also known as the system prompt.</li> <li>Agent Details: Programmatic metadata that describes the agent, including name, version, author, and other identifying information.</li> <li>Tools: External tools and services available to the agent (via MCP).</li> <li>Interface: Specifications for how agents expose themselves to the outside world, defining their callable signature and service endpoints.</li> <li>Model: Configuration for the Large Language Model (LLM) used by the agent (coming soon).</li> <li>Memory: Mechanisms for how agents can store and retrieve information across interactions (coming soon).</li> </ul>"},{"location":"specification/#3-file-format-and-content","title":"3. File Format and Content","text":"<p>An agent definition file must use the <code>*.afm.md</code> or <code>.afm</code> extension. </p> <p>The filename (without extension) serves as the Agent Identifier - a unique identifier for the agent within its namespace. This identifier is REQUIRED.</p> <p>Agent Identifier Rules: - Should not start with special characters, numbers, or whitespace - MUST be unique within the namespace to avoid conflicts </p> <p>The file content must be encoded in UTF-8. </p> <p>Best Practices for Naming AFM Files</p> <p>When naming your AFM files, following these best practices is RECOMMENDED to ensure clarity and consistency:</p> <ul> <li>Use lowercase letters, numbers, and hyphens to separate words.</li> <li>Avoid spaces and special characters to ensure compatibility across different systems.</li> </ul>"},{"location":"specification/#4-syntax-overview","title":"4. Syntax Overview","text":""},{"location":"specification/#41-basic-structure","title":"4.1. Basic Structure","text":"<p>An AFM file is structured into two main sections: the front matter and the agent declaration.</p> <ul> <li>Front Matter: Contains metadata about the agent.</li> <li>Markdown Body: Contains the agent's main declaration.</li> </ul>"},{"location":"specification/#42-front-matter","title":"4.2. Front Matter","text":"<p>The front matter is a YAML block at the top of the file, enclosed by <code>---</code> lines. Refer to the YAML specification for more details on YAML syntax.</p> <p>This section contains metadata about the agent. These metadata fields are OPTIONAL and can be used to provide additional context or configuration for the agent.</p> Section Description Agent Details Information about the agent, such as its name, description, version, and author. Agent Interface Defines how the agent is invoked and its input/output signature. Agent Tools Defines external tools available to the agent (e.g., via MCP). Agent Resources Coming soon <p>Refer to the AFM Schema for a complete list of fields and their meanings.</p>"},{"location":"specification/#43-markdown-body","title":"4.3.  Markdown Body","text":"<p>This section contains the detailed, natural language instructions that guide the agent's behavior. Use headings (<code>#</code>, <code>##</code>, etc.) to structure the prompt. Users can use markdown syntax to format the text, including lists, links, and code blocks.</p> <p>The Markdown body SHOULD contain the following headings, with corresponding content</p> <ul> <li><code># Role</code>: A brief description of the agent's role.</li> <li><code># Instructions</code>: A list of the agent's instructions for system prompt</li> </ul>"},{"location":"specification/#44-example","title":"4.4. Example","text":"<p>Basic AFM File Example</p> <p>Here is a simple example of an AFM file:</p> <pre><code>---\nname: \"Math Tutor\"\ndescription: \"An AI assistant that helps with mathematics problems\"\nversion: \"1.0.0\"\nnamespace: \"education\"\nauthors:\n  - \"Jane Smith &lt;jane@example.com&gt;\"\nlicense: \"MIT\"\n---\n\n# Role\nThe Math Tutor is an AI agent designed to assist students with mathematics problems, providing explanations, step-by-step solutions, and practice exercises.\n\n# Instructions\n- Use clear and concise language when explaining concepts.\n- Provide examples to illustrate complex ideas.\n- Encourage students to think critically and solve problems independently.\n- Answer questions about mathematical concepts\n- Solve equations and provide step-by-step solutions\n- Generate practice problems and quizzes when requested\n- Provide explanations and tips for solving math problems\n</code></pre>"},{"location":"specification/#5-schema-definitions","title":"5. Schema Definitions","text":"<p>This section defines the schema for the Front Matter. For clarity, the schema is divided into several subsections, each detailing a specific aspect of the Agent.</p>"},{"location":"specification/#51-about-the-agent","title":"5.1. About the Agent","text":"<p>This section defines the schema for agent-specific metadata. It is OPTIONAL but recommended for clarity and organization.</p> <p>AFM implementations SHALL use this section to display the agent's metadata in user interfaces to provide better user experience for end users.</p>"},{"location":"specification/#511-schema-overview","title":"5.1.1. Schema Overview","text":"<p>The agent metadata fields are specified in the YAML frontmatter of an AFM file:</p> <pre><code># Agent metadata schema\nname: string           # The name of the agent\ndescription: string    # Brief description of the agent's purpose and functionality\nversion: string        # Semantic version (e.g., \"1.0.0\")\nnamespace: string      # Logical grouping category for the agent\nauthor: string         # Single author in format \"Name &lt;Email&gt;\"\nauthors:               # Takes precedence over author field if both exist\n  - string             # Multiple authors, each in format \"Name &lt;Email&gt;\"\nprovider: object       # Agent provider\n  organization: string # Name of the organization\n  url: string          # URL to the organization's website\niconUrl: string        # URL to an icon representing the agent\nlicense: string        # License under which the agent is released\n</code></pre>"},{"location":"specification/#agent-field-definitions","title":"5.1.2. Field Definitions","text":"<p>Each field serves a specific purpose in defining and organizing the agent:</p> Field Type Required Description <code>name</code> <code>string</code> No Identifies the agent in human-readable form.Default: inferred from the filename of the AFM file.AFM implementations SHALL use this field to display the agent's name in user interfaces. <code>description</code> <code>string</code> No Provides a concise summary of what the agent does.Default: inferred from the markdown body <code># Role</code> section.AFM implementations SHALL use this field to display the agent's description in user interfaces. <code>version</code> <code>string</code> No Semantic version of the agent definition (MAJOR.MINOR.PATCH).Default: \"0.0.0\".AFM implementations SHALL use this field to display the agent's version in user interfaces. <code>namespace</code> <code>string</code> No Logical grouping category for the agent.Default: \"default\".AFM implementations SHALL use this field to organize agents into logical groups or categories. <code>author</code> <code>string</code> No Single author in format <code>Name &lt;Email&gt;</code>.Credits the creator of the agent definition. If both <code>author</code> and <code>authors</code> fields are provided, <code>authors</code> takes precedence. <code>authors</code> <code>string[]</code> No Multiple authors, each in format <code>Name &lt;Email&gt;</code>.Credits the creators of the agent definition. Takes precedence over <code>author</code> if both exist. <code>iconUrl</code> <code>string</code> No URL to an icon representing the agent.This is OPTIONAL but recommended for visual representation in user interfaces.AFM implementations SHALL use this field to display the agent's icon in user interfaces. <code>provider</code> <code>object</code> No Information about the organization providing the agent.This is OPTIONAL but recommended for attribution.See the Provider Object below for details. <code>license</code> <code>string</code> No License under which the agent definition is released.This is OPTIONAL but recommended for clarity. <p>Provider Object:</p> Field Type Required Description <code>provider.organization</code> <code>string</code> No Name of the organization providing the agent. <code>provider.url</code> <code>string</code> No URL to the organization's website."},{"location":"specification/#513-example-usage","title":"5.1.3. Example Usage","text":"<p>Here's an example of agent metadata in an AFM file:</p> <pre><code>---\nname: \"Math Tutor\"\ndescription: \"An AI assistant that helps with mathematics problems\"\nversion: \"1.2.0\"\nnamespace: \"education\"\nauthors:\n  - \"Jane Smith &lt;jane@example.com&gt;\"\n  - \"John Doe &lt;john@example.com&gt;\"\nprovider:\n    organization: \"Example AI Solutions\"\n    url: \"https://example.com\"\niconUrl: \"https://example.com/icons/math-tutor.png\"\nlicense: \"MIT\"\n---\n</code></pre>"},{"location":"specification/#52-agent-interface","title":"5.2. Agent Interface","text":"<p>This section defines the agent's public \"API\" or \"function signature.\" It is OPTIONAL and specifies how the agent receives inputs and produces outputs.</p> <p>Default values will be used if the interface is not explicitly defined. Users can override the default values by specifying the <code>interface</code> field in the front matter.</p> <p>Default Behavior: - The default <code>type</code> is <code>function</code>, which means the agent is callable within an application - The default <code>signature</code> (for both <code>function</code> and <code>service</code> types) includes:   - One string input parameter named <code>user_prompt</code>   - One string output parameter named <code>response</code></p> <p>AFM implementations SHALL use this definition to generate the agent's callable interface and to ensure consistent behavior across different platforms. </p>"},{"location":"specification/#521-schema-overview","title":"5.2.1. Schema Overview","text":"<pre><code>interface:\n  type: string           # The invocation style: 'service' or 'function'.\n  signature:\n    input: [object]      # A list of input parameter objects.\n    output: [object]     # A list of output parameter objects.\n  exposure:              # Optional, for 'service' type agents.\n    http: object         # Configuration for exposing as an HTTP endpoint.\n    a2a: object          # Configuration for exposing as an A2A-compliant service.\n</code></pre>"},{"location":"specification/#522-field-definitions","title":"5.2.2. Field Definitions","text":"Field Type Required Description <code>type</code> <code>string</code> Yes The agent's invocation style. Must be one of:- <code>service</code>: A network-accessible agent.- <code>function</code>: An agent callable within an application. <code>signature</code> <code>object</code> Yes Defines the agent's input and output parameters. See Signature Object. <code>exposure</code> <code>object</code> No Configuration for how a <code>service</code> agent is exposed. See Exposure Object. <p> Signature Object:</p> <p>Defines the data contract for the agent.</p> Field Type Required Description <code>input</code> <code>array</code> Yes An array of objects, each defining a named input parameter. The dynamic \"user prompt\" should be defined here. <code>output</code> <code>array</code> Yes An array of objects, each defining a named output parameter. <p>Each <code>input</code> or <code>output</code> object has the following structure:</p> Key Type Description <code>name</code> <code>string</code> The name of the parameter (e.g., <code>user_prompt</code>). <code>type</code> <code>string</code> The data type. Common types include: <code>string</code>, <code>number</code>, <code>boolean</code>, <code>json</code>, <code>array</code>, <code>file</code>. The full set of supported types is implementation-specific. <code>description</code> <code>string</code> A brief explanation of the parameter. <code>required</code> <code>boolean</code> (For <code>input</code> only) Whether the parameter is mandatory. <p> Exposure Object:</p> <p>Contains configurations for <code>service</code> agents.</p> Field Type Required Description <code>http</code> <code>object</code> No Defines how to expose the agent via a standard HTTP endpoint. <code>a2a</code> <code>object</code> No Defines how the agent is exposed and discovered within an A2A network. See Section 6.2 for Agent Card details. <p>WIP</p> <p>Work in progress: There are more details to be added for <code>http</code> and <code>a2a</code> exposure configurations. Also there are more other exposure types planned for future versions of AFM.</p> <p>HTTP Object:</p> Field Type Required Description <code>path</code> <code>string</code> Yes The URL path segment for the agent's HTTP endpoint (e.g., <code>/math-tutor</code>). <code>authentication</code> <code>object</code> No Optional authentication configuration for the HTTP endpoint. Uses the same schema as the MCP Authentication Object. <p>HTTP Object Usage</p> <p>The <code>http</code> object is only applicable for agents of type <code>service</code>. It defines how the agent is exposed via a standard HTTP endpoint, allowing other systems to interact with it over the web.</p> <p>AFM does not define the HTTP methods (GET, POST, etc.) for the agent's endpoint. This is left to the implementation to decide based on the agent's functionality and requirements.</p> <p>HTTP authentication follows the same pattern as MCP authentication, where the <code>type</code> field specifies the authentication scheme (e.g., <code>oauth2</code>, <code>api_key</code>), and the agent's host environment is responsible for managing the actual credentials and authentication flow.</p>"},{"location":"specification/#523-example-usage","title":"5.2.3. Example Usage","text":"<p>Here's an example of a service agent with custom interface and multiple exposure types:</p> <pre><code>interface:\n  type: service\n  signature:\n    input:\n      - name: user_prompt\n        type: string\n        description: \"The user's query or request\"\n        required: true\n      - name: context\n        type: json\n        description: \"Additional context for the request\"\n        required: false\n    output:\n      - name: response\n        type: string\n        description: \"The agent's response to the user prompt\"\n      - name: confidence\n        type: number\n        description: \"Confidence score for the response\"\n  exposure:\n    http:\n      path: \"/research-assistant\"\n    a2a:\n      discoverable: true\n      agent_card:\n        name: \"Research Assistant\"\n        description: \"Expert in finding, analyzing, and summarizing research papers\"\n        icon: \"https://example.com/icons/research-assistant.png\"\n</code></pre>"},{"location":"specification/#53-tools","title":"5.3. Tools","text":"<p>This section defines which external tools and resources the agent can access.</p>"},{"location":"specification/#531-schema-overview","title":"5.3.1. Schema Overview","text":"<p>The tools fields are specified in the YAML frontmatter of an AFM file:</p> <pre><code>tools:\n  mcp: object         # Configuration for connecting to MCP tools.\n</code></pre>"},{"location":"specification/#532-field-definitions","title":"5.3.2. Field Definitions","text":"Field Type Required Description <code>tools</code> <code>object</code> No Container for protocol-specific tool connection configurations. <code>tools.mcp</code> <code>object</code> No Configuration for Model Context Protocol. See Section 6.1 for details. <p>MCP Object:</p> Field Type Required Description <code>servers</code> <code>array</code> Yes List of MCP servers to connect to. See Section 6.1 for detailed schema."},{"location":"specification/#533-example-usage","title":"5.3.3. Example Usage","text":"<p>Here's a simple example of tools in an AFM file:</p> <pre><code>tools:\n  mcp:\n    servers:\n      - name: \"github_api\"\n        transport:\n          type: \"http_sse\"\n          url: \"https://mcp.github.com/api\"\n</code></pre>"},{"location":"specification/#54-agent-resources","title":"5.4. Agent Resources","text":"<p>This section defines the schema for resources that an agent can access or utilize from the implementation environment. These resources can be models, memory or other data sources that the agent can leverage to perform its tasks.</p> <p>This section is OPTIONAL. </p> <p>WIP</p> <p>Work in progress: The schema for agent resources is still under development. This section will be updated in future versions of the AFM specification.</p>"},{"location":"specification/#6-protocol-extensions","title":"6. Protocol Extensions","text":"<p>This section provides detailed specifications for the protocols referenced in above schema. These protocols enable agents to communicate with external systems and other agents.</p>"},{"location":"specification/#61-model-context-protocol-mcp","title":"6.1. Model Context Protocol (MCP)","text":"<p>The Model Context Protocol (MCP) enables agents to connect to external tools and data sources.</p>"},{"location":"specification/#611-schema-overview","title":"6.1.1. Schema Overview","text":"<pre><code>mcp:\n  servers:\n    - name: string           # Unique identifier for the server connection\n      transport:\n        type: string         # Transport mechanism (http_sse, stdio, streamable_http)\n        url: string          # URL endpoint (for http_sse and streamable_http)\n        command: string      # Shell command (for stdio)\n      authentication:        # Optional\n        type: string         # Authentication scheme (oauth2, api_key, etc.)\n      tool_filter:           # Optional\n        allow: [string]      # Whitelist of tools in \"tool_name\" format\n        deny: [string]       # Blacklist of tools in \"tool_name\" format\n</code></pre>"},{"location":"specification/#612-field-definitions","title":"6.1.2. Field Definitions","text":"Key Type Required Description <code>servers</code> Array Yes Specifies the MCP servers that the agent can connect to. Each server entry must have a unique <code>name</code> that identifies the connection. <p>Server Object:</p> Key Type Required Description <code>name</code> String Yes A unique, human-readable identifier for the connection. <code>transport</code> Object Yes An object defining the communication mechanism. See Transport Object below. <code>authentication</code> Object No An object declaring the required authentication scheme. See Authentication Object below. <code>tool_filter</code> Object No Filter configuration for tools from this server. See Tool Filter Object below. <p>Transport Object:</p> Key Type Required Description <code>type</code> String Yes Transport mechanism, which must be one of:- <code>http_sse</code>: Server-Sent Events over HTTP- <code>stdio</code>: Standard input/output for local processes- <code>streamable_http</code>: HTTP with streaming capabilities <code>url</code> String For HTTP types The URL endpoint of the remote MCP server. <code>command</code> String For stdio The shell command used to start the local MCP server process. <p>Authentication Object:</p> Key Type Required Description <code>type</code> String Yes Authentication scheme (e.g., <code>oauth2</code>, <code>api_key</code>).The agent's host environment is responsible for managing the actual credentials and authentication flow. <p>Tool Filter Object:</p> Key Type Required Description <code>allow</code> String Array No A whitelist of tools to expose from this server, using just the tool name (e.g., <code>create_issue</code>, <code>read_file</code>). If specified, only these tools are available. <code>deny</code> String Array No A blacklist of tools to hide from this server, using just the tool name (e.g., <code>write_file</code>). Applied after <code>allow</code> filtering. <p>Filter Precedence</p> <p>When both <code>allow</code> and <code>deny</code> are specified: 1. First, if <code>allow</code> is present, only the tools in the allow list are made available 2. Then, <code>deny</code> is applied to remove specific tools from that filtered set</p> <p>If only <code>deny</code> is specified, all tools from the server are available except those in the deny list.</p>"},{"location":"specification/#613-example-implementation","title":"6.1.3. Example Implementation","text":"<p>This example defines tool connections to a remote GitHub MCP server (requiring OAuth 2.0) and a local filesystem server. Each server has its own tool filter configuration.</p> <pre><code>tools:\n  mcp:\n    servers:\n      - name: github_mcp_server\n        transport:\n          type: http_sse\n          url: \"https://mcp.github.com/api\"\n        authentication:\n          type: oauth2\n        tool_filter:\n          allow:\n            - \"create_issue\"\n            - \"list_repositories\"\n\n      - name: local_filesystem_server\n        transport:\n          type: stdio\n          command: \"npx -y @modelcontextprotocol/server-filesystem\"\n        tool_filter:\n          allow:\n            - \"read_file\"\n          deny:\n            - \"write_file\"\n</code></pre>"},{"location":"specification/#62-agent-to-agent-a2a","title":"6.2. Agent-to-Agent (A2A)","text":"<p>The Agent-to-Agent Protocol (A2A) enables agents to expose themselves as services that other agents can discover and call, forming a multi-agent system where tasks can be delegated and information can be shared.</p>"},{"location":"specification/#621-schema-overview","title":"6.2.1. Schema Overview","text":"<pre><code>interface:\n  exposure:\n    a2a:\n      discoverable: boolean  # Whether the agent should be discoverable by other agents\n      agent_card:            # Optional metadata for agent discovery\n        name: string         # Display name for the agent in service directories\n        description: string  # Brief description of the agent's service capabilities\n        icon: string         # URL to an icon representing the agent service\n</code></pre>"},{"location":"specification/#622-field-definitions","title":"6.2.2. Field Definitions","text":"<p>A2A Exposure Object:</p> Key Type Required Description <code>discoverable</code> Boolean No Controls whether the agent is listed in service directories for other agents to find. Default: <code>true</code> when exposing as a service. <code>agent_card</code> Object No Contains metadata used when the agent is listed in service directories. See Agent Card Object below. <p>Agent Card Object:</p> Key Type Required Description <code>name</code> String No Display name for the agent in service directories. Default: Uses the agent's name from its metadata. <code>description</code> String No Brief description of what services the agent provides. Default: Uses the agent's description from its metadata. <code>icon</code> String No URL to an icon representing the agent service. Default: Uses the agent's iconUrl from its metadata."},{"location":"specification/#623-example-implementation","title":"6.2.3. Example Implementation","text":"<p>This example defines an agent that exposes itself as a discoverable A2A service with custom agent card information:</p> <pre><code>interface:\n  type: service\n  exposure:\n    http:\n      path: \"/research-assistant\"\n    a2a:\n      discoverable: true\n      agent_card:\n        name: \"Research Assistant\"\n        description: \"Expert in finding, analyzing, and summarizing research papers\"\n        icon: \"https://example.com/icons/research-assistant.png\"\n</code></pre>"},{"location":"specification/#7-future-work","title":"7. Future Work","text":"<p>This section outlines potential future enhancements to the AFM specification, including:</p> <ul> <li>Model configuration for specifying the Large Language Model (LLM) used by the agent.</li> <li>Memory management for agents to store and retrieve information across interactions.</li> <li>Configurable support for Agent declaration. </li> </ul>"},{"location":"topics/","title":"Topics","text":"<p>Explore in-depth articles about various aspects of AFM:</p> <ul> <li>Why AFM? - Learn about the philosophy and necessity behind Agent Flavored Markdown</li> <li>AFM: The Blueprint for a Connected Agent - Discover how AFM serves as the connective tissue for MCP and A2A protocols</li> </ul>"},{"location":"topics/afm-connected-agent/","title":"AFM: The Blueprint for a Connected Agent","text":"<p>In the rapidly expanding universe of AI, building a powerful agent is only the beginning. The true challenge lies in making that agent a functional part of a larger ecosystem. This requires clear standards for what an agent is, what tools it can use, and how it collaborates. While protocols like the Model Context Protocol (MCP) provide a \"toolbox\" for agents and the Agent-to-Agent (A2A) Protocol provides the \"communication channel,\" Agent Flavored Markdown (AFM) is the blueprint that connects the agent's definition to these powerful capabilities.</p> <p>An AFM file's role extends far beyond a simple description; it is the central configuration layer that activates an agent's ability to interact with the world. This is achieved through the <code>tools</code> block (for MCP tools) and the <code>interface</code> block (for A2A exposure) within the AFM front matter\u2014simple yet powerful sections that transform a static definition into a dynamic, enabled entity.</p> <ul> <li> <p> MCP: The Toolbox</p> <p>Gives agents access to external tools and services, expanding their capabilities beyond conversation.</p> </li> <li> <p> A2A: The Communication Channel</p> <p>Enables agents to discover and collaborate with each other, sharing tasks and information.</p> </li> </ul>"},{"location":"topics/afm-connected-agent/#equipping-agents-with-tools-via-mcp","title":"Equipping Agents with Tools via MCP","text":"<p>An agent's utility is measured by what it can do. AFM specifies this by declaring which MCP servers the agent is authorized to use.</p> <p>Within the <code>tools.mcp</code> section, an AFM file lists the specific MCP tool servers the agent can access. This could be a connection to a GitHub API, a local filesystem, or a corporate database.</p> <pre><code># In an AFM file...\ntools:\n  mcp:\n    servers:\n      - name: github_api_server\n        transport:\n          type: http_sse\n          url: \"https://mcp.github.com/api\"\n      - name: local_file_system\n        transport:\n          type: stdio\n</code></pre> <p>By defining these tool connections, the AFM file does more than describe an agent; it equips it. It hands the agent its specific toolkit, making it instantly capable of performing tasks like creating a GitHub issue or reading a local file. This declarative approach means you can change an agent's tools and capabilities simply by editing its AFM file, without touching a line of runtime code.</p>"},{"location":"topics/afm-connected-agent/#what-afm-provides","title":"What AFM Provides","text":"<ul> <li>Declarative tool configuration</li> <li>Authorization boundaries</li> <li>Transport specifications</li> <li>Tool filtering capabilities</li> </ul>"},{"location":"topics/afm-connected-agent/#benefits","title":"Benefits","text":"<ul> <li>Zero Code Changes: Modify tools without changing runtime code</li> <li>Clear Boundaries: Explicitly define what an agent can and cannot access</li> <li>Portable Configuration: The same definition works across implementations</li> </ul>"},{"location":"topics/afm-connected-agent/#making-agents-collaborative-with-a2a","title":"Making Agents Collaborative with A2A","text":"<p>Coming Soon</p> <p>The A2A protocol integration for agent collaboration is under development and will be available in a future version of the AFM specification.</p>"},{"location":"topics/afm-connected-agent/#the-complete-picture","title":"The Complete Picture","text":"<p>By serving as the declarative bridge to both MCP and A2A, AFM provides the essential configuration that brings an agent to life. It is the practical, portable blueprint that takes an agent from a standalone concept to a fully-connected participant in a modern AI ecosystem.</p>"},{"location":"topics/afm-connected-agent/#from-static-to-dynamic","title":"From Static to Dynamic","text":"<p>AFM transforms a static agent description into a dynamic, connected entity that can:</p> <ul> <li>Access specific tools through MCP</li> <li>Collaborate with other agents through A2A</li> <li>Maintain clear boundaries and permissions</li> </ul>"},{"location":"topics/afm-connected-agent/#practical-benefits","title":"Practical Benefits","text":"<ul> <li>Composability: Build complex systems from simple components</li> <li>Flexibility: Change tool connections and exposure without changing code</li> <li>Transparency: Clear documentation of an agent's capabilities</li> </ul>"},{"location":"topics/why-afm/","title":"Why AFM? A New Standard for a Multi-Agent World","text":"<p>The world of artificial intelligence is experiencing a Cambrian explosion. AI agents, designed to perform tasks autonomously, are being built by countless teams across the globe, using a vast array of different technologies and frameworks. This rapid innovation is exciting, but it has created a fragmented and chaotic landscape. How can an agent built by one team interact with an agent built by another? How can we define, manage, and scale these digital workers without getting locked into proprietary systems or drowning in boilerplate code?</p> <p>Agent Flavored Markdown (AFM) is an open standard designed to solve this problem. It provides a common language for describing what an agent is, what it can do, and how it behaves, paving the way for a truly interoperable ecosystem.</p>"},{"location":"topics/why-afm/#the-developers-dilemma","title":"The Developer's Dilemma","text":"<p>Today, developers face a frustrating dilemma when building AI agents, regardless of their preferred coding style.</p> <p>We are at a unique moment in technological history. Given the highly experimental and rapidly evolving nature of AI, committing to a permanent, language-level syntax for agents would be premature. At the same time, the current library-based approach provides a poor and inefficient developer experience.</p>"},{"location":"topics/why-afm/#pro-code-developers","title":"Pro-Code Developers","text":"<p>The experience of defining an agent is often verbose and unnecessarily complex. The agent's core identity\u2014its instructions and personality\u2014is frequently just a multi-line string literal buried within imperative code. This makes the agent difficult to manage, version, and share.</p>"},{"location":"topics/why-afm/#low-code-developers","title":"Low-Code Developers","text":"<p>Visual, low-code tooling can hide this complexity behind a friendly interface. However, the underlying representation is typically a proprietary Domain-Specific Language (DSL). This locks developers into a specific platform, limits flexibility, and makes it difficult to integrate with other systems.</p>"},{"location":"topics/why-afm/#the-solution-a-declarative-framework","title":"The Solution: A Declarative Framework","text":"<p>The optimal path forward is a declarative agent framework that serves as a powerful middle ground. This framework is built upon a dedicated syntax designed to be both human-readable and machine-parsable, bridging the gap between pro-code and low-code development.</p> <ul> <li> <p> Declarative Syntax</p> <p>Move away from complex, imperative code. AFM allows developers to declare an agent's properties, tools, and configurations in a simple, text-based format.</p> </li> <li> <p> Adaptable</p> <p>By building the framework around a flexible format rather than embedding it deep within a programming language, we can evolve the standard alongside the fast-changing AI landscape.</p> </li> <li> <p> Unified Experience</p> <p>Provide a clean, declarative model that works seamlessly for both developers writing code and those using a visual, low-code interface. The same AFM file can power both experiences.</p> </li> <li> <p> Agent Duality</p> <p>Natively support the dual nature of agents as both callable functions within an application and as exposable services for interoperability. This critical configuration is managed declaratively, not through code.</p> </li> </ul>"},{"location":"topics/why-afm/#why-markdown-the-perfect-format-for-agents","title":"Why Markdown? The Perfect Format for Agents","text":"<p>Finding a format that is both easily readable by humans and easily parsable by machines is crucial. While formats like JSON, TOML, or YAML are excellent for configuration, an AI agent is more than just configuration\u2014its essence is captured in its natural language instructions.</p> <p>This is why Markdown emerges as the ideal candidate.</p> <p>This elegant structure allows an agent's configuration, its documentation, and its core instructions to coexist in a single, version-controllable file. AFM is more than just a file format; it's a foundational step toward a future where intelligent agents can collaborate seamlessly, unlocking the true potential of a connected, multi-agent world.</p>"},{"location":"topics/why-afm/#benefits-of-markdown","title":"Benefits of Markdown","text":"<ul> <li> Familiar to software engineers</li> <li> Low barrier to entry</li> <li> Human-readable and machine-parsable</li> <li> Perfect for natural language instructions</li> <li> Supports structured and semi-structured content</li> </ul>"},{"location":"topics/why-afm/#afm-structure","title":"AFM Structure","text":"<p>Front Matter (Structured Metadata): The YAML front matter provides a structured, machine-readable section for defining the agent's configuration (its name, interface, tool connections, etc.).</p> <p>Markdown Body (Semi-structured Document): The body of the document provides a human- and AI-first authoring experience for the agent's detailed system prompt.</p>"}]}